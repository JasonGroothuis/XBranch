apply plugin: "cpp"

//def opencl_home = System.getenv('CUDA_PATH_V6_5')
def cuda_home = System.getenv('CUDA_PATH_V6_5')
def cuda_files = '.\\src\\main\\cuda\\'
def cuda_includes = ''

model {
    buildTypes {
//        debug
        release
    }

    platforms {
        x86 {
            architecture "x86"
        }
        x64 {
            architecture "x86_64"
        }
    }   
    
    toolChains {
        visualCpp(VisualCpp) {
            // Specify the installDir if Visual Studio cannot be located
			if ( project.hasProperty('vcinstallDir') )	{
				installDir project.properties['vcinstallDir']
			} else {
	//            installDir "C:/Program Files (x86)/Microsoft Visual Studio 10.0"
			}
			if ( project.hasProperty('vcwindowsSdkDir') )	{
				windowsSdkDir project.properties['vcwindowsSdkDir']
			}
			else {
	//			windowsSdkDir "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.1A"
			}
        }
    }
   
    components {
        main(NativeExecutableSpec) {
			targetPlatform "x86"
			targetPlatform "x64"
            binaries.all {
                if (toolChain in Gcc) {
                    cppCompiler.args "-fno-access-control", "-fconserve-space"
					if (buildType == buildTypes.debug) {
						cppCompiler.args "-g"
					}
				}
                if (toolChain in VisualCpp) {
//                    cppCompiler.args "-I"+opencl_home+"/include"
                    cppCompiler.args "/EHsc"
//					linker.args "OpenCL.lib"
//					linker.args "delayimp.lib","/DELAYLOAD:OpenCL.dll","/DELAY:UNLOAD"
					
					println "===> " + targetPlatform.name + "  " + buildType.name + " <==="
					if ( targetPlatform.name == 'x86' ) {
//						linker.args "/LIBPATH:" + opencl_home + "/lib/Win32"
						if (buildType == buildTypes.release) {
							cppCompiler.args "/O2","/MT"                    
							cppCompiler.define 'NDEBUG'
//							def cuObjDir = file("$buildDir/objs/main/x86/release/mainCuda")
							def cuObjDir = file("$buildDir/objs/main/x86/mainCuda")
							linker.args "/LIBPATH:" + cuda_home + "/lib/Win32"
							linker.args "cudart_static.lib"
							linker.args "/LIBPATH:" + cuObjDir							
							vclinkfiles.tokenize().each {
									linker.args it
							}
							culinkfiles.tokenize().each {
									linker.args it
							}
						}
/*
						if (buildType == buildTypes.debug) {
							cppCompiler.args "/MTd"                    
							cppCompiler.args '/Zi'
							cppCompiler.define 'DEBUG'
							linker.args '/DEBUG'
						}													
*/
					}
					if ( targetPlatform.name == 'x64' ) {
//						linker.args "/LIBPATH:" + opencl_home + "/lib/x64"
						if (buildType == buildTypes.release) {
							cppCompiler.args "/O2","/MT"                    
							cppCompiler.define 'NDEBUG'
//							def cuObjDir = file("$buildDir/objs/main/x64/release/mainCuda")
							def cuObjDir = file("$buildDir/objs/main/x64/mainCuda")
							linker.args "/LIBPATH:" + cuda_home + "/lib/x64"
							linker.args "cudart_static.lib"
							linker.args "/LIBPATH:" + cuObjDir							
							vclinkfiles.tokenize().each {
									linker.args it
							}
							culinkfiles.tokenize().each {
									linker.args it
							}
						}
/*
						if (buildType == buildTypes.debug) {
							cppCompiler.args "/MTd"                    
							cppCompiler.args '/Zi'
							cppCompiler.define 'DEBUG'
							linker.args '/DEBUG'
						}													
*/
					}
				}									
            }
        }
    }
	tasks { t ->
		$.components.main.binaries.each { binary ->
			def stripTask = binary.tasks.taskName("strip")
			t.create(stripTask) {
				dependsOn binary.tasks.link
				doFirst {
					if (binary.toolChain in Gcc) {
						["strip", binary.tasks.link.outputFile].execute()
					}
				}
			}
			binary.tasks.build.dependsOn stripTask
		}
	}	
	tasks { nvcomp ->
		$.components.main.binaries.each { binary ->
			def nvcompTask = binary.tasks.taskName("nvcomp")
			nvcomp.create(nvcompTask) {
				//dependsOn compileCuda
				doFirst {
					println "<<<------------nvcomp task ----------->>>"
					println "Type " + nvcompTask
				}
			}
			binary.tasks.link.dependsOn nvcompTask			
		}
	}							
}
tasks.addRule("Pattern: cucomp<ID>") { String taskName ->

	if (   taskName.startsWith("nvcomp")
		&& taskName.contains("Main")
		&& taskName.contains("X86") 
		&& taskName.contains("Executable") )  {
//		&& taskName.contains("Release") 
		task(taskName) << {
			println "CUCOMP: " + (taskName)
			def nvcmdline = cuda_home+'\\bin\\nvcc'
			def cuSrcDir = file('src/main/cuda')
//			def outputDir = file("$buildDir/objs/main/x86/release/mainCuda")
			def outputDir = file("$buildDir/objs/main/x86/mainCuda")
			if ( !outputDir.exists() ) {
				outputDir.mkdir()
			}
			println "***Compiling Cuda Sources at " + cuSrcDir
			def cucollection = files { cuSrcDir.listFiles() }
			cucollection.files.each { String thefile = it
				if ( thefile.endsWith('.cu') ) {
					println thefile
				}
			}
			cucollection.collect {it}.each { 
				println it
				String srcfname = it
				if (it.name.endsWith('.cu')) {
					String ofname = it.getName()[0..-3] + 'obj'
					println srcfname + '---->' + ofname
					project.exec {
						workingDir outputDir
						commandLine nvcmdline, 
						'-ccbin','\"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin\"',
						"--machine","32","--compile", "-maxrregcount=32", 
						'-gencode=arch=compute_35,code=\\"sm_35,compute_35\\"',
						'-Xcompiler', '\"/EHsc /W1 /nologo /O2 /Zi  /MT  \"',	
						'-o',outputDir.getAbsolutePath() + '/' + ofname,
						srcfname				
					}		
				}
			}				
		}
	} //type
	else if (   taskName.startsWith("nvcomp")
		&& taskName.contains("Main")
		&& taskName.contains("X64") 
		&& taskName.contains("Executable") )  {
//		&& taskName.contains("Release") 
		task(taskName) << {
			println "CUCOMP: " + (taskName)
			def nvcmdline = cuda_home+'\\bin\\nvcc'
			def cuSrcDir = file('src/main/cuda')
//			def outputDir = file("$buildDir/objs/main/x64/release/mainCuda")
			def outputDir = file("$buildDir/objs/main/x64/mainCuda")
			if ( !outputDir.exists() ) {
				outputDir.mkdir()
			}
			println "***Compiling Cuda Sources at " + cuSrcDir
			def cucollection = files { cuSrcDir.listFiles() }
			cucollection.files.each { String thefile = it
				if ( thefile.endsWith('.cu') ) {
					println thefile
				}
			}
			cucollection.collect {it}.each { 
				println it
				String srcfname = it
				if (it.name.endsWith('.cu')) {
					String ofname = it.getName()[0..-3] + 'obj'
					println srcfname + '---->' + ofname
					
					project.exec {
						workingDir outputDir
						commandLine nvcmdline, 
						'-ccbin','\"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin\"',
						"--machine","64","--compile", "-maxrregcount=32", 
						'-gencode=arch=compute_35,code=\\"sm_35,compute_35\\"',
						'-Xcompiler', '\"/EHsc /W1 /nologo /O2 /Zi  /MT  \"',	
						'-o',outputDir.getAbsolutePath() + '/' + ofname,
						srcfname				
					}					
				}
			}				
		}
	} //type
	
	// Add other build types here
}		//task		


//task nvccVersion(type:Exec) {
//	workingDir '.'
//	def nvcmdline = cuda_home+'\\bin\\nvcc'
//	doFirst{
//		println 'Cuda path is ' + cuda_home
//		println 'working directory is ' + workingDir		
//	}
//	commandLine nvcmdline, '--version'	
//}

//task compileCuda(type:nvccCompile) {
//    inputDir = file(cuda_files)
//    outputDir = file("$buildDir/cuobjs/")
//    inputProperty = project.properties['taskInputProperty'] ?: "original"	
//	cuSrcDir = file('src/main/cuda')
//	cucollection = files { cuSrcDir.listFiles() }
//	nvcmdline = cuda_home+'\\bin\\nvcc'		
//}
/*
class nvccCompile extends DefaultTask {
    @InputDirectory 
	def File inputDir
    @OutputDirectory
	def File outputDir
	@Input
    def inputProperty	
	@Input
	def File cuSrcDir
	@Input
	def FileCollection cucollection
	@Input
	def String nvcmdline
    @TaskAction
    def doNvccCompile(IncrementalTaskInputs inputs) {
		println '<=======IN doNvccCompile()========>'		
        println inputs.incremental ? "CHANGED inputs considered out of date"
                                   : "ALL inputs considered out of date"
		println "Contents of " + cuSrcDir.getAbsolutePath()
		cucollection.collect {it}.each { 
			println it
			String srcfname = it
			if (it.name.endsWith('.cu')) {
				String ofname = it.getName()[0..-3] + '.o'
				project.exec {
					commandLine nvcmdline, 
					'-ccbin','\"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin\"',
					"--machine","32","--compile", "-maxrregcount=32", 
					'-gencode=arch=compute_35,code=\\"sm_35,compute_35\\"',
					'-Xcompiler', '\"/EHsc /W1 /nologo /O2 /Zi  /MT  \"',	
					'-o',outputDir.getAbsolutePath() + '//' + ofname,
					srcfname				
				}		
			}
		}
    }
}
*/
/*
FileCollection collection

task list {
    File srcDir

    // Create a file collection using a closure
    collection = files { srcDir.listFiles() }

    srcDir = file('src/main/cpp')
    println "Contents of $srcDir.name"
    collection.collect { relativePath(it) }.sort().each { println it }

    srcDir = file('src/main/cuda')
    println "Contents of $srcDir.name"
    collection.collect { relativePath(it) }.sort().each { println it }
}
*/
/*
task nvccCompile(type:Exec) {
//	workingDir '.'
	def nvcmdline = cuda_home+'\\bin\\nvcc'
	doFirst{
		println 'Cuda path is ' + cuda_home
		println 'working directory is ' + workingDir		
	}
	commandLine nvcmdline,
	'-ccbin','\"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin\"',
	"--machine","32","--compile", "-maxrregcount=32", 
	'-gencode=arch=compute_35,code=\\"sm_35,compute_35\\"',
	'-Xcompiler', '\"/EHsc /W1 /nologo /O2 /Zi  /MT  \"',	
	'-o',cuda_files+'test.o',
	cuda_files+'test.cu'
}
*/
